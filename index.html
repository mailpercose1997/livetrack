<!DOCTYPE html>
<html>
<head>
    <title>Tastiera Virtuale Gestuale - Esagono come Modalità</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; background: #222; font-family: sans-serif; }
        .container { 
            position: relative; 
            border: 5px solid #00aaff;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.5);
        }
        video {
            transform: scaleX(-1); 
            position: absolute; 
            top: 0; 
            left: 0; 
            display: block; 
        }
        canvas {
            position: absolute; 
            top: 0; 
            left: 0; 
            display: block; 
        }
        #output-text {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%); 
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1.5em;
            min-width: 80%;
            text-align: center;
            border: 2px solid #00aaff;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="container">
        <video id="webcam" autoplay playsinline muted></video>
        <canvas id="output"></canvas>
        <div id="output-text">Caricamento modelli... attendere.</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script> 
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script> 
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>

    <script>
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('output');
        const canvasCtx = canvasElement.getContext('2d');
        const outputTextElement = document.getElementById('output-text');
        
        let handDetector;
        let typedText = "";
        
        // --- RIGHE DI CARATTERI MULTIPLE ---
        const CHARS_ROW_1 = "QWERTYUIOP"; 
        const CHARS_ROW_2 = "ASDFGHJKL";
        const CHARS_ROW_3 = "ZXCVBNM.,";
        const CHARS_SYMBOLS = "1234567890";
        let currentChars = CHARS_ROW_1; 
        
        let selectedChar = CHARS_ROW_1[0]; 
        
        const ROTATION_SENSITIVITY = 0.8; 

        // Variabili per il Menu di Digitazione (Mano Sinistra)
        let isMenuToggledOn = false; 
        let isRightPinchActive = false; // Usato per l'evidenziazione della digitazione
        
        // Variabili per il cambio di riga (debounce)
        let lastRowChangeTime = 0;
        const ROW_CHANGE_DELAY = 500; 

        // --- VARIABILI PER IL NUOVO ESAGONO DI SELEZIONE (Mano Destra) ---
        let isHexagonActive = false;
        
        const HEXAGON_FUNCTIONS = [
            // Funzione principale: Attiva/Disattiva la modalità di digitazione (mano sinistra)
            { name: "ATTIVA DIGITAZIONE", action: () => { isMenuToggledOn = true; currentChars = CHARS_ROW_1; } },
            { name: "DISEGNA", action: () => { isMenuToggledOn = false; } },
            
            { name: "ALTRO", action: () => { updateText('SPACE'); } },
            { name: "ALTRO", action: () => { updateText('DEL'); } },

            { name: "ALTRO", action: () => { console.log("MAIUSC Attivo!"); } },
            { name: "ALTRO", action: () => { console.log("Comando X eseguito!"); } }
        ];
        
        let hexSelectorAngle = 0;
        let selectedHexFunction = HEXAGON_FUNCTIONS[0].name;
        let hexSelectionStartTime = 0;
        const HEX_CONFIRM_TIME = 800; // Tempo in ms per confermare la selezione
        
        let lastActionTime = 0;
        const ACTION_DELAY = 500; 

        // --- FUNZIONI UTILITY ---
        
        async function setupCamera() {
             try {
                const stream = await navigator.mediaDevices.getUserMedia({ 'video': true });
                videoElement.srcObject = stream;
                return new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        canvasElement.width = videoElement.videoWidth;
                        canvasElement.height = videoElement.videoHeight;
                        const container = document.querySelector('.container');
                        container.style.width = `${videoElement.videoWidth}px`;
                        container.style.height = `${videoElement.videoHeight}px`;
                        resolve(true);
                    };
                });
            } catch (error) {
                console.error("Errore nell'accesso alla webcam:", error);
                alert("Impossibile accedere alla webcam. Assicurati di aver dato il permesso.");
                return false;
            }
        }

        async function loadDetectors() {
            outputTextElement.textContent = "Caricamento modelli di tracciamento...";
            await tf.setBackend('webgl');
            const handModel = handPoseDetection.SupportedModels.MediaPipeHands;
            handDetector = await handPoseDetection.createDetector(handModel, {
                runtime: 'mediapipe',
                modelType: 'full', 
                solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands'
            });
            outputTextElement.textContent = typedText || "Gesto Pollice-Indice-Medio (destra) per Esagono di Controllo.";
        }

        function calculateDistance(p1, p2) {
            return Math.sqrt(
                Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)
            );
        }
        
        function getPinchData(hand) {
            const thumbTip = hand.keypoints[4]; 
            const PINCH_THRESHOLD = 30; 
            
            // Includi Indice, Medio, Anulare, Mignolo per la mano sinistra
            const fingerTips = [
                { name: 'Indice', tip: hand.keypoints[8] },
                { name: 'Medio', tip: hand.keypoints[12] },
                { name: 'Anulare', tip: hand.keypoints[16] },
                { name: 'Mignolo', tip: hand.keypoints[20] } 
            ];
            const results = [];
            fingerTips.forEach(finger => {
                const distance = calculateDistance(thumbTip, finger.tip);
                if (distance < PINCH_THRESHOLD){
                    results.push({
                        finger: finger.name,
                        isPinching: true, 
                        tipCoordinates: finger.tip
                    });
                }
            });
            return results;
        }

        function isFingerUp(hand, fingerBaseIndex) {
            // Un dito è "alzato" se la punta (baseIndex + 3) è sopra o molto lontana dalla falange intermedia (baseIndex + 1)
            const fingerTip = hand.keypoints[fingerBaseIndex + 3];
            const fingerBase = hand.keypoints[fingerBaseIndex];
            
            // Confronto con l'altezza della base
            return fingerTip.y < fingerBase.y; 
        }

        function getHandRotationAngle(hand) {
            const wrist = hand.keypoints[0];      
            const palmCenter = hand.keypoints[9]; 
            const deltaX = palmCenter.x - wrist.x;
            const deltaY = palmCenter.y - wrist.y;
            let angleDeg = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
            if (angleDeg < 0) angleDeg += 360; 
            return angleDeg;
        }

        function updateText(char) {
            if (char === 'DEL') {
                typedText = typedText.slice(0, -1);
            } else if (char === 'SPACE') {
                typedText += ' ';
            } else if (char.length === 1) {
                typedText += char;
            }
            outputTextElement.textContent = typedText || "Gesto Pollice-Indice-Medio (destra) per Esagono di Controllo.";
        }
        
        // --- FUNZIONI DI DISEGNO ---
        
        function drawHands(hands) {
            canvasCtx.fillStyle = '#00FF00'; 
            canvasCtx.strokeStyle = '#00FF00'; 
            canvasCtx.lineWidth = 2;
            for (const hand of hands) {
                const keypoints = hand.keypoints;
                const fingerConnections = [
                    [0, 1], [1, 2], [2, 3], [3, 4], 
                    [0, 5], [5, 6], [6, 7], [7, 8], 
                    [0, 9], [9, 10], [10, 11], [11, 12], 
                    [0, 13], [13, 14], [14, 15], [15, 16], 
                    [0, 17], [17, 18], [18, 19], [19, 20] 
                ];
                for (const [start, end] of fingerConnections) {
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(keypoints[start].x, keypoints[start].y);
                    canvasCtx.lineTo(keypoints[end].x, keypoints[end].y);
                    canvasCtx.stroke();
                }
                for (const point of keypoints) {
                    canvasCtx.beginPath();
                    canvasCtx.arc(point.x, point.y, 3, 0, 2 * Math.PI); 
                    canvasCtx.fill();
                }
            }
        }
        
        function drawCharMenu(center, radius, currentAngle) {
            canvasCtx.save();
            canvasCtx.translate(center.x, center.y); 

            // Disegna il cerchio centrale
            canvasCtx.beginPath();
            canvasCtx.arc(0, 0, radius * 0.4, 0, 2 * Math.PI); 
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            canvasCtx.fill();

            const CHAR_COUNT = currentChars.length;
            const angleStep = 360 / CHAR_COUNT;

            // Applicazione del fattore di sensibilità
            let scaledAngle = currentAngle * ROTATION_SENSITIVITY;
            
            for (let i = 0; i < CHAR_COUNT; i++) {
                const char = currentChars[i];
                const charAngle = (i * angleStep - 90) * (Math.PI / 180); 
                
                const charX = radius * Math.cos(charAngle);
                const charY = radius * Math.sin(charAngle);

                // Normalizza l'angolo SCALATO per la selezione
                let normalizedCurrentAngle = scaledAngle + 90; 
                while (normalizedCurrentAngle > 360) normalizedCurrentAngle -= 360;
                while (normalizedCurrentAngle < 0) normalizedCurrentAngle += 360;

                const startAngle = i * angleStep;
                const endAngle = (i + 1) * angleStep;

                const isSelected = normalizedCurrentAngle >= startAngle && normalizedCurrentAngle < endAngle;

                if (isSelected) {
                    canvasCtx.beginPath();
                    canvasCtx.arc(charX, charY, 18, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = isRightPinchActive ? '#FF6347' : '#00aaff'; 
                    canvasCtx.fill();
                    selectedChar = char; // Imposta il carattere globale
                }
                
                canvasCtx.fillStyle = isSelected ? '#000000' : '#FFFFFF';
                canvasCtx.font = 'bold 20px sans-serif';
                canvasCtx.textAlign = 'center';
                canvasCtx.textBaseline = 'middle';
                canvasCtx.fillText(char, charX, charY);
            }
            
            canvasCtx.fillStyle = isRightPinchActive ? '#FF6347' : '#FFFFFF';
            canvasCtx.font = 'bold 28px sans-serif';
            canvasCtx.fillText(selectedChar, 0, 0); 

            canvasCtx.restore(); 
        }

        // --- FUNZIONE: DISEGNO ESAGONO ---
        function drawHexagonSelector(center, radius, currentAngle, currentTime) {
            canvasCtx.save();
            canvasCtx.translate(center.x, center.y); 

            const sideCount = HEXAGON_FUNCTIONS.length; // 6 lati
            const angleStep = 360 / sideCount;

            // Normalizza l'angolo di rotazione della mano destra
            let normalizedCurrentAngle = currentAngle + 90; 
            while (normalizedCurrentAngle > 360) normalizedCurrentAngle -= 360;
            while (normalizedCurrentAngle < 0) normalizedCurrentAngle += 360;
            
            // Trova la funzione selezionata
            let currentSelectedIndex = Math.floor(normalizedCurrentAngle / angleStep);
            if (currentSelectedIndex >= sideCount) currentSelectedIndex = 0;
            
            // Calcola il progresso della conferma
            const selectionDuration = currentTime - hexSelectionStartTime;
            const progress = Math.min(1, selectionDuration / HEX_CONFIRM_TIME);
            
            // SE IL PUNTATORE È CAMBIATO, RESETTA IL TEMPO
            if (HEXAGON_FUNCTIONS[currentSelectedIndex].name !== selectedHexFunction) {
                 hexSelectionStartTime = currentTime;
                 selectedHexFunction = HEXAGON_FUNCTIONS[currentSelectedIndex].name;
            }

            canvasCtx.strokeStyle = 'rgba(0, 170, 255, 0.9)';
            canvasCtx.lineWidth = 4;
            canvasCtx.font = 'bold 16px sans-serif';
            canvasCtx.textAlign = 'center';
            canvasCtx.textBaseline = 'middle';

            // Disegna l'esagono e le funzioni
            canvasCtx.beginPath();
            for (let i = 0; i < sideCount; i++) {
                const angleRad = (i * angleStep - 90) * (Math.PI / 180);
                const x = radius * Math.cos(angleRad);
                const y = radius * Math.sin(angleRad);
                
                if (i === 0) canvasCtx.moveTo(x, y);
                else canvasCtx.lineTo(x, y);
                
                // Punti di testo al centro del lato
                const textAngleRad = ((i + 0.5) * angleStep - 90) * (Math.PI / 180);
                const textX = radius * 0.7 * Math.cos(textAngleRad);
                const textY = radius * 0.7 * Math.sin(textAngleRad);

                const isCurrent = i === currentSelectedIndex;
                
                canvasCtx.fillStyle = isCurrent ? '#FF00FF' : '#FFFFFF';
                canvasCtx.fillText(HEXAGON_FUNCTIONS[i].name, textX, textY);
            }
            canvasCtx.closePath();
            canvasCtx.stroke();
            
            // Indicatore di selezione (Progresso)
            canvasCtx.beginPath();
            canvasCtx.arc(0, 0, radius * 0.4, 0, 2 * Math.PI * progress); 
            canvasCtx.fillStyle = `rgba(0, 255, 0, ${0.5 + progress * 0.5})`;
            canvasCtx.fill();
            
            // Disegna il centro (sovrapposto)
            canvasCtx.beginPath();
            canvasCtx.arc(0, 0, 8, 0, 2 * Math.PI); 
            canvasCtx.fillStyle = 'rgba(255, 255, 255, 1)';
            canvasCtx.fill();


            // Seleziona la funzione se il tempo è scaduto
            if (progress >= 1 && selectionDuration > 0) {
                 HEXAGON_FUNCTIONS[currentSelectedIndex].action();
                 hexSelectionStartTime = currentTime; // Reset del timer
                 isHexagonActive = false; // Disattiva l'esagono dopo l'azione
            }
            
            canvasCtx.restore(); 
        }


        // --- Loop di Tracciamento Principale ---
        async function runDetection() {
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            const currentTime = Date.now();
            isRightPinchActive = false;
            
            if (handDetector && videoElement.readyState >= 2) {
                
                canvasCtx.save();
                canvasCtx.translate(canvasElement.width, 0);
                canvasCtx.scale(-1, 1);
                canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

                const hands = await handDetector.estimateHands(videoElement, { flipHorizontal: false });
                drawHands(hands); 
                canvasCtx.restore(); 
                
                let menuCenter = null;
                let menuAngle = 0;
                let rightHandRotation = 0;
                
                // Presumi disattivazione dell'esagono a meno che non si trovi il gesto in questo frame
                let shouldActivateHexagon = false;

                for (const hand of hands) {
                    const handLabel = hand.handedness; 
                    const pinchData = getPinchData(hand);

                    // ----------------------------------------------------------------------
                    // LOGICA MANO SINISTRA: ROTAZIONE E CAMBIO RIGA (Solo se Menu Attivo)
                    // ----------------------------------------------------------------------
                    if (handLabel === 'Left') {
                        // Calcola sempre posizione e angolo
                        menuCenter = {
                            x: canvasElement.width - hand.keypoints[9].x, 
                            y: hand.keypoints[9].y
                        };
                        menuAngle = getHandRotationAngle(hand);
                        
                        // Gestione Cambio Riga (Solo se Menu Attivo)
                        if (isMenuToggledOn && (currentTime - lastRowChangeTime > ROW_CHANGE_DELAY)) {
                            const indexPinch = pinchData.find(res => res.finger === 'Indice' && res.isPinching);
                            const medioPinch = pinchData.find(res => res.finger === 'Medio' && res.isPinching);
                            const anularePinch = pinchData.find(res => res.finger === 'Anulare' && res.isPinching);
                            const mignoloPinch = pinchData.find(res => res.finger === 'Mignolo' && res.isPinching);

                            if (indexPinch) {
                                currentChars = CHARS_ROW_1;
                                lastRowChangeTime = currentTime;
                            } else if (medioPinch) {
                                currentChars = CHARS_ROW_2;
                                lastRowChangeTime = currentTime;
                            } else if (anularePinch) {
                                currentChars = CHARS_ROW_3;
                                lastRowChangeTime = currentTime;
                            } else if (mignoloPinch) {
                                currentChars = CHARS_SYMBOLS;
                                lastRowChangeTime = currentTime;
                            }
                            // Resetta il carattere selezionato al primo del nuovo set
                            if (lastRowChangeTime === currentTime) {
                                selectedChar = currentChars[0];
                            }
                        }
                    }

                    // ----------------------------------------------------------------------
                    // LOGICA MANO DESTRA: ESAGONO DI CONTROLLO E DIGITAZIONE
                    // ----------------------------------------------------------------------
                    else if (handLabel === 'Right') {
                        // 1. Gesto Esagono: Pollice, Indice e Medio alzati
                        const isIndexUp = isFingerUp(hand, 5); 
                        const isMiddleUp = isFingerUp(hand, 9);
                        const isRingDown = !isFingerUp(hand, 13); // Anulare e mignolo giù
                        const isPinkyDown = !isFingerUp(hand, 17);
                        
                        if (isIndexUp && isMiddleUp && isRingDown && isPinkyDown) {
                            shouldActivateHexagon = true;
                            rightHandRotation = getHandRotationAngle(hand);
                            // Se l'esagono è attivo, ignora l'input di digitazione
                            continue; 
                        }
                        
                        // 2. Azione di Digitazione (solo se Menu Attivo e Esagono NON Attivo)
                        if (isMenuToggledOn && !isHexagonActive) {
                            const indexPinch = pinchData.find(res => res.finger === 'Indice' && res.isPinching);

                            if (indexPinch) {
                                isRightPinchActive = true; 
                                
                                // Pinch Indice (Destra) = SELEZIONA CARATTERE
                                if (currentTime - lastActionTime > ACTION_DELAY) {
                                    updateText(selectedChar);
                                    lastActionTime = currentTime;
                                }
                            }
                        }
                    }
                }
                
                // --- 4. GESTIONE STATO GLOBALE ---
                
                // A. Attiva/Disattiva Esagono
                if (shouldActivateHexagon) {
                    isHexagonActive = true;
                } else if (!isHexagonActive) {
                    // Se l'esagono non è attivo, ma non è stato rilevato, resetta il timer.
                    hexSelectionStartTime = currentTime;
                }
                
                // B. Se l'esagono era attivo, ma il gesto è stato interrotto, disattiva
                if (isHexagonActive && !shouldActivateHexagon && hexSelectionStartTime === currentTime) {
                    isHexagonActive = false; 
                }
                

                // --- 5. RENDERING FINALE ---
                if (isHexagonActive) {
                    drawHexagonSelector({ x: canvasElement.width / 2, y: canvasElement.height / 2 }, 150, rightHandRotation, currentTime);
                } else if (isMenuToggledOn && menuCenter) {
                    drawCharMenu(menuCenter, 100, menuAngle);
                }
            }

            requestAnimationFrame(runDetection);
        }

        // --- Avvio Applicazione ---
        async function main() {
            try {
                await tf.ready(); 
                const cameraReady = await setupCamera();
                if (!cameraReady) return;
                await loadDetectors();
                runDetection(); 
            } catch (error) {
                console.error("Errore fatale nell'applicazione:", error);
                outputTextElement.textContent = `ERRORE: ${error.message}. Controlla la console.`;
            }
        }

        main();
    </script>
</body>
</html>