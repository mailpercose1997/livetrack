<!DOCTYPE html>
<html>
<head>
    <title>Tastiera Virtuale Gestuale - Modalità Master con Abbassamento</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; background: #222; font-family: sans-serif; }
        .container { 
            position: relative; 
            border: 5px solid #00aaff;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.5);
        }
        video {
            transform: scaleX(-1); 
            position: absolute; 
            top: 0; 
            left: 0; 
            display: block; 
        }
        canvas {
            position: absolute; 
            top: 0; 
            left: 0; 
            display: block; 
        }
        #output-text {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%); 
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1.5em;
            min-width: 80%;
            text-align: center;
            border: 2px solid #00aaff;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="container">
        <video id="webcam" autoplay playsinline muted></video>
        <canvas id="output"></canvas>
        <div id="output-text">Caricamento modelli... attendere.</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script> 
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script> 
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>

    <script>
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('output');
        const canvasCtx = canvasElement.getContext('2d');
        const outputTextElement = document.getElementById('output-text');
        
        let handDetector;
        let typedText = "";
        
        // --- MODALITÀ DI STATO GLOBALE ---
        const HEXAGON_MENU = 'HEXAGON_MENU';
        const TYPING_MODE = 'TYPING_MODE';
        const DRAWING_MODE = 'DRAWING_MODE'; 
        
        let currentMode = HEXAGON_MENU; 
        
        // --- CONFIGURAZIONI DIGITAZIONE ---
        const CHARS_ROW_1 = "QWERTYUIOP"; 
        const CHARS_ROW_2 = "ASDFGHJKL";
        const CHARS_ROW_3 = "ZXCVBNM.,";
        const CHARS_SYMBOLS = "1234567890";
        let currentChars = CHARS_ROW_1; 
        let selectedChar = CHARS_ROW_1[0]; 
        const ROTATION_SENSITIVITY = 0.8; 
        let isRightPinchActive = false; 
        let lastRowChangeTime = 0;
        const ROW_CHANGE_DELAY = 500; 
        
        // --- CONFIGURAZIONI ESAGONO ---
        // Stato: TRUE quando le dita sono alzate (per la navigazione)
        let isHexagonGestureActive = false; 
        // Stato: FALSE quando le dita sono abbassate, ma la selezione DEVE avvenire.
        let wasHexagonGestureActive = false; 

        const HEXAGON_FUNCTIONS = [
            { name: "DIGITAZIONE", action: () => { currentMode = TYPING_MODE; currentChars = CHARS_ROW_1; selectedChar = CHARS_ROW_1[0]; } },
            { name: "DISEGNA (FUTURO)", action: () => { currentMode = DRAWING_MODE; alert("Modalità Disegno non implementata."); } },
            { name: "SPAZIO", action: () => { updateText('SPACE'); currentMode = HEXAGON_MENU; } }, // Torna all'esagono dopo l'azione
            { name: "CANCELLA", action: () => { updateText('DEL'); currentMode = HEXAGON_MENU; } }, // Torna all'esagono dopo l'azione
            { name: "IMPOSTAZIONI (FUTURO)", action: () => { currentMode = HEXAGON_MENU; } },
            { name: "ESCI", action: () => { currentMode = HEXAGON_MENU; } } 
        ];
        
        let hexSelectorAngle = 0;
        // Manteniamo traccia della selezione corrente per attivarla al rilascio
        let currentSelectedHexIndex = 0; 
        
        let lastActionTime = 0;
        const ACTION_DELAY = 500; 

        // --- FUNZIONI UTILITY ---
        
        async function setupCamera() {
             try {
                const stream = await navigator.mediaDevices.getUserMedia({ 'video': true });
                videoElement.srcObject = stream;
                return new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        canvasElement.width = videoElement.videoWidth;
                        canvasElement.height = videoElement.videoHeight;
                        const container = document.querySelector('.container');
                        container.style.width = `${videoElement.videoWidth}px`;
                        container.style.height = `${videoElement.videoHeight}px`;
                        resolve(true);
                    };
                });
            } catch (error) {
                console.error("Errore nell'accesso alla webcam:", error);
                alert("Impossibile accedere alla webcam. Assicurati di aver dato il permesso.");
                return false;
            }
        }

        async function loadDetectors() {
            outputTextElement.textContent = "Caricamento modelli di tracciamento...";
            await tf.setBackend('webgl');
            const handModel = handPoseDetection.SupportedModels.MediaPipeHands;
            handDetector = await handPoseDetection.createDetector(handModel, {
                runtime: 'mediapipe',
                modelType: 'full', 
                solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands'
            });
            outputTextElement.textContent = typedText || `Modalità Attiva: ${currentMode}. Alza Pollice-Indice-Medio (destra) per l'Esagono.`;
        }

        function calculateDistance(p1, p2) {
            return Math.sqrt(
                Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)
            );
        }
        
        function getPinchData(hand) {
            const thumbTip = hand.keypoints[4]; 
            const PINCH_THRESHOLD = 30; 
            
            const fingerTips = [
                { name: 'Indice', tip: hand.keypoints[8] },
                { name: 'Medio', tip: hand.keypoints[12] },
                { name: 'Anulare', tip: hand.keypoints[16] },
                { name: 'Mignolo', tip: hand.keypoints[20] } 
            ];
            const results = [];
            fingerTips.forEach(finger => {
                const distance = calculateDistance(thumbTip, finger.tip);
                if (distance < PINCH_THRESHOLD){
                    results.push({
                        finger: finger.name,
                        isPinching: true, 
                        tipCoordinates: finger.tip
                    });
                }
            });
            return results;
        }

        function isFingerUp(hand, fingerBaseIndex) {
            // Indice=5, Medio=9, Anulare=13, Mignolo=17
            // Pollice (4) si controlla rispetto al polso (0) o all'Indice (5)
            // Per il pollice usiamo un check più semplice (punta sopra la base)
            const fingerTip = hand.keypoints[fingerBaseIndex + 3];
            const fingerBase = hand.keypoints[fingerBaseIndex];
            
            // Per Indice, Medio, Anulare, Mignolo: punta più alta della base della falange
            if (fingerBaseIndex !== 1) { // 1 non è una base di dito
                return fingerTip.y < fingerBase.y; 
            }
            return fingerTip.y < hand.keypoints[5].y; // Pollice: punta sopra la base dell'indice
        }
        
        // Controlla se il gesto Pollice-Indice-Medio è ATTIVO (dita alzate)
        function isHexagonGestureActiveCheck(hand) {
            const isIndexUp = isFingerUp(hand, 5); 
            const isMiddleUp = isFingerUp(hand, 9);
            const isThumbUp = isFingerUp(hand, 1); // Riferimento al Pollice (Punta 4, base 1)
            
            // Anulare e mignolo devono essere giù per evitare falsi positivi
            const isRingDown = !isFingerUp(hand, 13); 
            const isPinkyDown = !isFingerUp(hand, 17);
            
            return isIndexUp && isMiddleUp && isThumbUp && isRingDown && isPinkyDown;
        }


        function getHandRotationAngle(hand) {
            const wrist = hand.keypoints[0];      
            const palmCenter = hand.keypoints[9]; 
            const deltaX = palmCenter.x - wrist.x;
            const deltaY = palmCenter.y - wrist.y;
            let angleDeg = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
            if (angleDeg < 0) angleDeg += 360; 
            return angleDeg;
        }

        function updateText(char) {
            if (char === 'DEL') {
                typedText = typedText.slice(0, -1);
            } else if (char === 'SPACE') {
                typedText += ' ';
            } else if (char.length === 1) {
                typedText += char;
            }
            outputTextElement.textContent = typedText || `Modalità Attiva: ${currentMode}. Alza Pollice-Indice-Medio (destra) per l'Esagono.`;
        }
        
        // --- FUNZIONI DI DISEGNO ---
        
        function drawHands(hands) {
            canvasCtx.fillStyle = '#00FF00'; 
            canvasCtx.strokeStyle = '#00FF00'; 
            canvasCtx.lineWidth = 2;
            for (const hand of hands) {
                const keypoints = hand.keypoints;
                const fingerConnections = [
                    [0, 1], [1, 2], [2, 3], [3, 4], 
                    [0, 5], [5, 6], [6, 7], [7, 8], 
                    [0, 9], [9, 10], [10, 11], [11, 12], 
                    [0, 13], [13, 14], [14, 15], [15, 16], 
                    [0, 17], [17, 18], [18, 19], [19, 20] 
                ];
                for (const [start, end] of fingerConnections) {
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(keypoints[start].x, keypoints[start].y);
                    canvasCtx.lineTo(keypoints[end].x, keypoints[end].y);
                    canvasCtx.stroke();
                }
                for (const point of keypoints) {
                    canvasCtx.beginPath();
                    canvasCtx.arc(point.x, point.y, 3, 0, 2 * Math.PI); 
                    canvasCtx.fill();
                }
            }
        }
        
        // Disegno del menu di digitazione (quadrante rotante)
        function drawCharMenu(center, radius, currentAngle) {
            canvasCtx.save();
            canvasCtx.translate(center.x, center.y); 

            canvasCtx.beginPath();
            canvasCtx.arc(0, 0, radius * 0.4, 0, 2 * Math.PI); 
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            canvasCtx.fill();

            const CHAR_COUNT = currentChars.length;
            const angleStep = 360 / CHAR_COUNT;

            let scaledAngle = currentAngle * ROTATION_SENSITIVITY;
            
            for (let i = 0; i < CHAR_COUNT; i++) {
                const char = currentChars[i];
                const charAngle = (i * angleStep - 90) * (Math.PI / 180); 
                
                const charX = radius * Math.cos(charAngle);
                const charY = radius * Math.sin(charAngle);

                let normalizedCurrentAngle = scaledAngle + 90; 
                while (normalizedCurrentAngle > 360) normalizedCurrentAngle -= 360;
                while (normalizedCurrentAngle < 0) normalizedCurrentAngle += 360;

                const startAngle = i * angleStep;
                const endAngle = (i + 1) * angleStep;

                const isSelected = normalizedCurrentAngle >= startAngle && normalizedCurrentAngle < endAngle;

                if (isSelected) {
                    canvasCtx.beginPath();
                    canvasCtx.arc(charX, charY, 18, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = isRightPinchActive ? '#FF6347' : '#00aaff'; 
                    canvasCtx.fill();
                    selectedChar = char; 
                }
                
                canvasCtx.fillStyle = isSelected ? '#000000' : '#FFFFFF';
                canvasCtx.font = 'bold 20px sans-serif';
                canvasCtx.textAlign = 'center';
                canvasCtx.textBaseline = 'middle';
                canvasCtx.fillText(char, charX, charY);
            }
            
            canvasCtx.fillStyle = isRightPinchActive ? '#FF6347' : '#FFFFFF';
            canvasCtx.font = 'bold 28px sans-serif';
            canvasCtx.fillText(selectedChar, 0, 0); 

            canvasCtx.restore(); 
        }

        // --- FUNZIONE: DISEGNO ESAGONO ---
        function drawHexagonSelector(center, radius, currentAngle) {
            canvasCtx.save();
            canvasCtx.translate(center.x, center.y); 

            const sideCount = HEXAGON_FUNCTIONS.length; 
            const angleStep = 360 / sideCount;

            let normalizedCurrentAngle = currentAngle + 90; 
            while (normalizedCurrentAngle > 360) normalizedCurrentAngle -= 360;
            while (normalizedCurrentAngle < 0) normalizedCurrentAngle += 360;
            
            let currentSelectedIndex = Math.floor(normalizedCurrentAngle / angleStep);
            if (currentSelectedIndex >= sideCount) currentSelectedIndex = 0;
            
            // Aggiorna l'indice selezionato per la conferma al rilascio
            currentSelectedHexIndex = currentSelectedIndex;

            canvasCtx.strokeStyle = 'rgba(0, 170, 255, 0.9)';
            canvasCtx.lineWidth = 4;
            canvasCtx.font = 'bold 16px sans-serif';
            canvasCtx.textAlign = 'center';
            canvasCtx.textBaseline = 'middle';

            canvasCtx.beginPath();
            for (let i = 0; i < sideCount; i++) {
                const angleRad = (i * angleStep - 90) * (Math.PI / 180);
                const x = radius * Math.cos(angleRad);
                const y = radius * Math.sin(angleRad);
                
                if (i === 0) canvasCtx.moveTo(x, y);
                else canvasCtx.lineTo(x, y);
                
                const textAngleRad = ((i + 0.5) * angleStep - 90) * (Math.PI / 180);
                const textX = radius * 0.7 * Math.cos(textAngleRad);
                const textY = radius * 0.7 * Math.sin(textAngleRad);

                const isCurrent = i === currentSelectedIndex;
                
                canvasCtx.fillStyle = isCurrent ? '#FF00FF' : '#FFFFFF';
                canvasCtx.fillText(HEXAGON_FUNCTIONS[i].name, textX, textY);
            }
            canvasCtx.closePath();
            canvasCtx.stroke();
            
            // Disegna il centro come indicatore di selezione
            canvasCtx.beginPath();
            canvasCtx.arc(0, 0, 8, 0, 2 * Math.PI); 
            canvasCtx.fillStyle = 'rgba(255, 255, 255, 1)';
            canvasCtx.fill();

            // Evidenziazione dinamica al centro per indicare che è selezionato
            canvasCtx.beginPath();
            canvasCtx.arc(0, 0, radius * 0.3, 0, 2 * Math.PI); 
            canvasCtx.strokeStyle = '#FF00FF'; 
            canvasCtx.lineWidth = 2;
            canvasCtx.stroke();
            
            canvasCtx.restore(); 
        }


        // --- Loop di Tracciamento Principale ---
        async function runDetection() {
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            const currentTime = Date.now();
            isRightPinchActive = false;
            
            if (handDetector && videoElement.readyState >= 2) {
                
                canvasCtx.save();
                canvasCtx.translate(canvasElement.width, 0);
                canvasCtx.scale(-1, 1);
                canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

                const hands = await handDetector.estimateHands(videoElement, { flipHorizontal: false });
                drawHands(hands); 
                canvasCtx.restore(); 
                
                let rotationForMenu = 0;
                let rightHandIsVisibleAndActive = false;
                
                let isCurrentHexagonGestureActive = false;

                for (const hand of hands) {
                    const handLabel = hand.handedness; 
                    const pinchData = getPinchData(hand);
                    const handRotation = getHandRotationAngle(hand);
                    
                    // 1. Rilevamento Gesto Esagono (Mano Destra)
                    if (handLabel === 'Right') {
                        if (isHexagonGestureActiveCheck(hand)) {
                            isCurrentHexagonGestureActive = true;
                            rotationForMenu = handRotation; // Rotazione mano destra per l'Esagono
                            rightHandIsVisibleAndActive = true;
                            continue; // Ignora gli altri input della destra se il gesto Esagono è attivo
                        }
                    }
                    
                    // 2. Logica Specifica per la Modalità Attiva (Solo se Esagono NON Attivo)
                    if (!isHexagonGestureActive && currentMode === TYPING_MODE) {
                        
                        // MANO SINISTRA: Rotazione e Cambio Riga
                        if (handLabel === 'Left') {
                            rotationForMenu = handRotation; // Rotazione mano sinistra per il quadrante
                            
                            if (currentTime - lastRowChangeTime > ROW_CHANGE_DELAY) {
                                const indexPinch = pinchData.find(res => res.finger === 'Indice' && res.isPinching);
                                const medioPinch = pinchData.find(res => res.finger === 'Medio' && res.isPinching);
                                const anularePinch = pinchData.find(res => res.finger === 'Anulare' && res.isPinching);
                                const mignoloPinch = pinchData.find(res => res.finger === 'Mignolo' && res.isPinching);

                                if (indexPinch) currentChars = CHARS_ROW_1;
                                else if (medioPinch) currentChars = CHARS_ROW_2;
                                else if (anularePinch) currentChars = CHARS_ROW_3;
                                else if (mignoloPinch) currentChars = CHARS_SYMBOLS;
                                
                                if (indexPinch || medioPinch || anularePinch || mignoloPinch) {
                                    lastRowChangeTime = currentTime;
                                    selectedChar = currentChars[0];
                                }
                            }
                        }
                        
                        // MANO DESTRA: Digitazione (Pinch Indice)
                        else if (handLabel === 'Right') {
                            rightHandIsVisibleAndActive = true;
                            const indexPinch = pinchData.find(res => res.finger === 'Indice' && res.isPinching);

                            if (indexPinch) {
                                isRightPinchActive = true; 
                                if (currentTime - lastActionTime > ACTION_DELAY) {
                                    updateText(selectedChar);
                                    lastActionTime = currentTime;
                                }
                            }
                        }
                    }
                }

                // --- 3. GESTIONE SELEZIONE AL RILASCIO ---
                
                // Se il gesto era attivo nel frame precedente MA NON lo è più in questo frame
                if (wasHexagonGestureActive && !isCurrentHexagonGestureActive) {
                    // Esegui l'azione selezionata
                    HEXAGON_FUNCTIONS[currentSelectedHexIndex].action();
                    // Assicurati che il menu sia nascosto/disattivato
                    isHexagonGestureActive = false;
                    
                }

                // Aggiorna lo stato per il frame successivo
                wasHexagonGestureActive = isHexagonGestureActive;
                isHexagonGestureActive = isCurrentHexagonGestureActive;
                
                // Se siamo in modalità Esagono e la mano destra non è visibile, non c'è rotazione.
                if (currentMode === HEXAGON_MENU && !rightHandIsVisibleAndActive) {
                    isHexagonGestureActive = false;
                }
                
                // --- 4. RENDERING FINALE ---
                const center = { x: canvasElement.width / 2, y: canvasElement.height / 2 };

                if (isHexagonGestureActive || currentMode === HEXAGON_MENU) {
                    // Disegna l'Esagono se il gesto è attivo O se siamo in modalità Esagono (per mostrare le opzioni dopo la selezione)
                    drawHexagonSelector(center, 150, rotationForMenu);
                } else if (currentMode === TYPING_MODE) {
                    // Disegna il menu di Digitazione (usa la rotazione della mano sinistra o della destra se l'altra non c'è)
                    drawCharMenu(center, 100, rotationForMenu);
                } 

            }

            requestAnimationFrame(runDetection);
        }

        // --- Avvio Applicazione ---
        async function main() {
            try {
                await tf.ready(); 
                const cameraReady = await setupCamera();
                if (!cameraReady) return;
                await loadDetectors();
                runDetection(); 
            } catch (error) {
                console.error("Errore fatale nell'applicazione:", error);
                outputTextElement.textContent = `ERRORE: ${error.message}. Controlla la console.`;
            }
        }

        main();
    </script>
</body>
</html>