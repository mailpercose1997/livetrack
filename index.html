<!DOCTYPE html>
<html>
<head>
    <title>Tastiera Virtuale Gestuale - Versione Iniziale (A due mani)</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; background: #222; font-family: sans-serif; }
        .container { 
            position: relative; 
            border: 5px solid #ff5733;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(255, 87, 51, 0.5);
        }
        video {
            transform: scaleX(-1); 
            position: absolute; 
            top: 0; 
            left: 0; 
            display: block; 
        }
        canvas {
            position: absolute; 
            top: 0; 
            left: 0; 
            display: block; 
        }
        #output-text {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%); 
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1.5em;
            min-width: 80%;
            text-align: center;
            border: 2px solid #ff5733;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="container">
        <video id="webcam" autoplay playsinline muted></video>
        <canvas id="output"></canvas>
        <div id="output-text">Caricamento modelli... attendere.</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script> 
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script> 
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>

    <script>
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('output');
        const canvasCtx = canvasElement.getContext('2d');
        const outputTextElement = document.getElementById('output-text');
        
        let handDetector;
        let typedText = "";
        
        // --- RIGHE DI CARATTERI MULTIPLE ---
        const CHARS_ROW_1 = "QWERTYUIOP"; 
        const CHARS_ROW_2 = "ASDFGHJKL";
        const CHARS_ROW_3 = "ZXCVBNM.,";
        const CHARS_SYMBOLS = "1234567890";
        let currentChars = CHARS_ROW_1; 
        
        let selectedChar = CHARS_ROW_1[0]; 
        
        const ROTATION_SENSITIVITY = 0.8; 
        let isRightPinchActive = false;
        
        let lastActionTime = 0;
        const ACTION_DELAY = 500; 
        let lastRowChangeTime = 0;
        const ROW_CHANGE_DELAY = 500; 

        // --- FUNZIONI UTILITY ---
        
        async function setupCamera() {
             try {
                const stream = await navigator.mediaDevices.getUserMedia({ 'video': true });
                videoElement.srcObject = stream;
                return new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        canvasElement.width = videoElement.videoWidth;
                        canvasElement.height = videoElement.videoHeight;
                        const container = document.querySelector('.container');
                        container.style.width = `${videoElement.videoWidth}px`;
                        container.style.height = `${videoElement.videoHeight}px`;
                        resolve(true);
                    };
                });
            } catch (error) {
                console.error("Errore nell'accesso alla webcam:", error);
                alert("Impossibile accedere alla webcam. Assicurati di aver dato il permesso.");
                return false;
            }
        }

        async function loadDetectors() {
            outputTextElement.textContent = "Caricamento modelli di tracciamento...";
            await tf.setBackend('webgl');
            const handModel = handPoseDetection.SupportedModels.MediaPipeHands;
            handDetector = await handPoseDetection.createDetector(handModel, {
                runtime: 'mediapipe',
                modelType: 'full', 
                solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands'
            });
            outputTextElement.textContent = typedText || "Gesto mano sinistra per Menu Radiale. Pinch Pollice-Indice (destra) per digitare.";
        }

        function calculateDistance(p1, p2) {
            return Math.sqrt(
                Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)
            );
        }
        
        function getPinchData(hand) {
            const thumbTip = hand.keypoints[4]; 
            const PINCH_THRESHOLD = 30; 
            
            const fingerTips = [
                { name: 'Indice', tip: hand.keypoints[8] },
                { name: 'Medio', tip: hand.keypoints[12] },
                { name: 'Anulare', tip: hand.keypoints[16] },
                { name: 'Mignolo', tip: hand.keypoints[20] } 
            ];
            const results = [];
            fingerTips.forEach(finger => {
                const distance = calculateDistance(thumbTip, finger.tip);
                if (distance < PINCH_THRESHOLD){
                    results.push({
                        finger: finger.name,
                        isPinching: true, 
                        tipCoordinates: finger.tip
                    });
                }
            });
            return results;
        }

        function getHandRotationAngle(hand) {
            const wrist = hand.keypoints[0];      
            const palmCenter = hand.keypoints[9]; 
            const deltaX = palmCenter.x - wrist.x;
            const deltaY = palmCenter.y - wrist.y;
            let angleDeg = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
            if (angleDeg < 0) angleDeg += 360; 
            return angleDeg;
        }

        function updateText(char) {
            if (char === 'DEL') {
                typedText = typedText.slice(0, -1);
            } else if (char === 'SPACE') {
                typedText += ' ';
            } else if (char.length === 1) {
                typedText += char;
            }
            outputTextElement.textContent = typedText || "Gesto mano sinistra per Menu Radiale. Pinch Pollice-Indice (destra) per digitare.";
        }
        
        // --- FUNZIONI DI DISEGNO ---
        
        function drawHands(hands) {
            canvasCtx.fillStyle = '#00FF00'; 
            canvasCtx.strokeStyle = '#00FF00'; 
            canvasCtx.lineWidth = 2;
            for (const hand of hands) {
                const keypoints = hand.keypoints;
                const fingerConnections = [
                    [0, 1], [1, 2], [2, 3], [3, 4], 
                    [0, 5], [5, 6], [6, 7], [7, 8], 
                    [0, 9], [9, 10], [10, 11], [11, 12], 
                    [0, 13], [13, 14], [14, 15], [15, 16], 
                    [0, 17], [17, 18], [18, 19], [19, 20] 
                ];
                for (const [start, end] of fingerConnections) {
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(keypoints[start].x, keypoints[start].y);
                    canvasCtx.lineTo(keypoints[end].x, keypoints[end].y);
                    canvasCtx.stroke();
                }
                for (const point of keypoints) {
                    canvasCtx.beginPath();
                    canvasCtx.arc(point.x, point.y, 3, 0, 2 * Math.PI); 
                    canvasCtx.fill();
                }
            }
        }
        
        // Disegno del menu di digitazione (quadrante rotante)
        function drawCharMenu(center, radius, currentAngle) {
            canvasCtx.save();
            canvasCtx.translate(center.x, center.y); 

            canvasCtx.beginPath();
            canvasCtx.arc(0, 0, radius * 0.4, 0, 2 * Math.PI); 
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            canvasCtx.fill();

            const CHAR_COUNT = currentChars.length;
            const angleStep = 360 / CHAR_COUNT;

            // Applicazione del fattore di sensibilità
            let scaledAngle = currentAngle * ROTATION_SENSITIVITY;
            
            for (let i = 0; i < CHAR_COUNT; i++) {
                const char = currentChars[i];
                const charAngle = (i * angleStep - 90) * (Math.PI / 180); 
                
                const charX = radius * Math.cos(charAngle);
                const charY = radius * Math.sin(charAngle);

                // Normalizza l'angolo SCALATO per la selezione
                let normalizedCurrentAngle = scaledAngle + 90; 
                while (normalizedCurrentAngle > 360) normalizedCurrentAngle -= 360;
                while (normalizedCurrentAngle < 0) normalizedCurrentAngle += 360;

                const startAngle = i * angleStep;
                const endAngle = (i + 1) * angleStep;

                const isSelected = normalizedCurrentAngle >= startAngle && normalizedCurrentAngle < endAngle;

                if (isSelected) {
                    canvasCtx.beginPath();
                    canvasCtx.arc(charX, charY, 18, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = isRightPinchActive ? '#FF6347' : '#ff5733'; 
                    canvasCtx.fill();
                    selectedChar = char; // Imposta il carattere globale
                }
                
                canvasCtx.fillStyle = isSelected ? '#000000' : '#FFFFFF';
                canvasCtx.font = 'bold 20px sans-serif';
                canvasCtx.textAlign = 'center';
                canvasCtx.textBaseline = 'middle';
                canvasCtx.fillText(char, charX, charY);
            }
            
            canvasCtx.fillStyle = isRightPinchActive ? '#FF6347' : '#FFFFFF';
            canvasCtx.font = 'bold 28px sans-serif';
            canvasCtx.fillText(selectedChar, 0, 0); 

            canvasCtx.restore(); 
        }

        // --- Loop di Tracciamento Principale ---
        async function runDetection() {
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            const currentTime = Date.now();
            isRightPinchActive = false;
            
            if (handDetector && videoElement.readyState >= 2) {
                
                canvasCtx.save();
                canvasCtx.translate(canvasElement.width, 0);
                canvasCtx.scale(-1, 1);
                canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

                const hands = await handDetector.estimateHands(videoElement, { flipHorizontal: false });
                drawHands(hands); 
                canvasCtx.restore(); 
                
                let rotationForMenu = 0;
                let leftHandFound = false;

                for (const hand of hands) {
                    const handLabel = hand.handedness; 
                    const pinchData = getPinchData(hand);
                    const handRotation = getHandRotationAngle(hand);
                    
                    // MANO SINISTRA: Rotazione del Menu e Cambio Riga
                    if (handLabel === 'Left') {
                        leftHandFound = true;
                        rotationForMenu = handRotation; // Rotazione mano sinistra per il quadrante
                        
                        if (currentTime - lastRowChangeTime > ROW_CHANGE_DELAY) {
                            const indexPinch = pinchData.find(res => res.finger === 'Indice' && res.isPinching);
                            const medioPinch = pinchData.find(res => res.finger === 'Medio' && res.isPinching);
                            const anularePinch = pinchData.find(res => res.finger === 'Anulare' && res.isPinching);
                            const mignoloPinch = pinchData.find(res => res.finger === 'Mignolo' && res.isPinching);

                            if (indexPinch) currentChars = CHARS_ROW_1;
                            else if (medioPinch) currentChars = CHARS_ROW_2;
                            else if (anularePinch) currentChars = CHARS_ROW_3;
                            else if (mignoloPinch) currentChars = CHARS_SYMBOLS;
                            
                            if (indexPinch || medioPinch || anularePinch || mignoloPinch) {
                                lastRowChangeTime = currentTime;
                                selectedChar = currentChars[0];
                            }
                        }
                    }
                    
                    // MANO DESTRA: Azioni (Digitazione, Spazio, Delete)
                    else if (handLabel === 'Right') {
                        const indexPinch = pinchData.find(res => res.finger === 'Indice' && res.isPinching);
                        const medioPinch = pinchData.find(res => res.finger === 'Medio' && res.isPinching);
                        const anularePinch = pinchData.find(res => res.finger === 'Anulare' && res.isPinching);

                        if (currentTime - lastActionTime > ACTION_DELAY) {
                             if (indexPinch) {
                                 // Pinch Indice (Destra) = SELEZIONA CARATTERE
                                 updateText(selectedChar);
                                 isRightPinchActive = true;
                                 lastActionTime = currentTime;
                             } else if (medioPinch) {
                                 // Pinch Medio (Destra) = SPACE
                                 updateText('SPACE');
                                 lastActionTime = currentTime;
                             } else if (anularePinch) {
                                 // Pinch Anulare (Destra) = DELETE
                                 updateText('DEL');
                                 lastActionTime = currentTime;
                             }
                        }
                        
                        // Per il rendering, verifica solo il pinch Indice
                        if (indexPinch) {
                             isRightPinchActive = true; 
                        }
                    }
                }
                
                // Se la mano sinistra non è stata trovata, usa la rotazione della mano destra
                if (!leftHandFound) {
                    const rightHand = hands.find(h => h.handedness === 'Right');
                    if (rightHand) {
                        rotationForMenu = getHandRotationAngle(rightHand);
                    }
                }

                // RENDERING
                const leftHand = hands.find(h => h.handedness === 'Left');
                let menuCenter;
                
                // Centra il menu sulla mano sinistra se trovata, altrimenti al centro dello schermo
                if (leftHand) {
                    menuCenter = {
                        x: canvasElement.width - leftHand.keypoints[9].x, 
                        y: leftHand.keypoints[9].y
                    };
                } else {
                    menuCenter = { x: canvasElement.width / 2, y: canvasElement.height / 2 };
                }
                
                drawCharMenu(menuCenter, 100, rotationForMenu);
            }

            requestAnimationFrame(runDetection);
        }

        // --- Avvio Applicazione ---
        async function main() {
            try {
                await tf.ready(); 
                const cameraReady = await setupCamera();
                if (!cameraReady) return;
                await loadDetectors();
                runDetection(); 
            } catch (error) {
                console.error("Errore fatale nell'applicazione:", error);
                outputTextElement.textContent = `ERRORE: ${error.message}. Controlla la console.`;
            }
        }

        main();
    </script>
</body>
</html>