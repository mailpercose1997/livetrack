<!DOCTYPE html>
<html>
<head>
    <title>Tastiera Virtuale Gestuale - Esagono Stile Fisso</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; background: #222; font-family: sans-serif; }
        .container { 
            position: relative; 
            border: 5px solid #00aaff;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.5);
        }
        video {
            transform: scaleX(-1); 
            position: absolute; 
            top: 0; 
            left: 0; 
            display: block; 
        }
        canvas {
            position: absolute; 
            top: 0; 
            left: 0; 
            display: block; 
        }
        #output-text {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%); 
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1.5em;
            min-width: 80%;
            text-align: center;
            border: 2px solid #00aaff;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="container">
        <video id="webcam" autoplay playsinline muted></video>
        <canvas id="output"></canvas>
        <div id="output-text">Caricamento modelli... attendere.</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script> 
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script> 
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>

    <script>
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('output');
        const canvasCtx = canvasElement.getContext('2d');
        const outputTextElement = document.getElementById('output-text');
        
        let handDetector;
        let typedText = "";
        
        // --- MODALITÀ DI STATO GLOBALE ---
        const HEXAGON_MENU = 'HEXAGON_MENU';
        const TYPING_MODE = 'TYPING_MODE';
        const DRAWING_MODE = 'DRAWING_MODE'; 
        
        let currentMode = TYPING_MODE; // Iniziamo in Modalità Digitazione per semplicità, ma l'Esagono deve essere selezionabile.
        
        // --- CONFIGURAZIONI DIGITAZIONE ---
        const CHARS_ROW_1 = "QWERTYUIOP"; 
        const CHARS_ROW_2 = "ASDFGHJKL";
        const CHARS_ROW_3 = "ZXCVBNM.,";
        const CHARS_SYMBOLS = "1234567890";
        let currentChars = CHARS_ROW_1; 
        let selectedChar = CHARS_ROW_1[0]; 
        const ROTATION_SENSITIVITY = 0.8; 
        let isRightPinchActive = false; 
        let lastRowChangeTime = 0;
        const ROW_CHANGE_DELAY = 500; 
        
        // --- CONFIGURAZIONI ESAGONO (MODALITÀ) ---
        let isHexagonGestureActive = false; 
        let wasHexagonGestureActive = false; 

        const HEXAGON_FUNCTIONS = [
            { name: "DIGITAZIONE", action: () => { currentMode = TYPING_MODE; } },
            { name: "DISEGNA (FUTURO)", action: () => { currentMode = DRAWING_MODE; alert("Modalità Disegno non implementata."); } },
            // Le funzioni di sistema ora cambiano ANCHE la riga del quadrante se siamo in modalità digitazione
            { name: "SPAZIO", action: () => { updateText('SPACE'); } },
            { name: "CANCELLA", action: () => { updateText('DEL'); } },
            { name: "RIGA SUCCESSIVA", action: () => { cycleTypingRow(); } },
            { name: "RIGA PRECEDENTE", action: () => { cycleTypingRow(true); } } 
        ];
        
        // Variabili per la selezione radiale, sempre attiva quando il gesto Esagono è in corso
        let hexSelectorAngle = 0;
        let currentSelectedHexIndex = 0; 
        
        let lastActionTime = 0;
        const ACTION_DELAY = 500; 
        
        // --- UTILITY ---
        function cycleTypingRow(reverse = false) {
             const rows = [CHARS_ROW_1, CHARS_ROW_2, CHARS_ROW_3, CHARS_SYMBOLS];
             let currentIndex = rows.findIndex(row => row === currentChars);
             
             if (reverse) {
                 currentIndex = (currentIndex - 1 + rows.length) % rows.length;
             } else {
                 currentIndex = (currentIndex + 1) % rows.length;
             }
             
             currentChars = rows[currentIndex];
             selectedChar = currentChars[0];
        }

        async function setupCamera() {
             try {
                const stream = await navigator.mediaDevices.getUserMedia({ 'video': true });
                videoElement.srcObject = stream;
                return new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        canvasElement.width = videoElement.videoWidth;
                        canvasElement.height = videoElement.videoHeight;
                        const container = document.querySelector('.container');
                        container.style.width = `${videoElement.videoWidth}px`;
                        container.style.height = `${videoElement.videoHeight}px`;
                        resolve(true);
                    };
                });
            } catch (error) {
                console.error("Errore nell'accesso alla webcam:", error);
                alert("Impossibile accedere alla webcam. Assicurati di aver dato il permesso.");
                return false;
            }
        }

        async function loadDetectors() {
            outputTextElement.textContent = "Caricamento modelli di tracciamento...";
            await tf.setBackend('webgl');
            const handModel = handPoseDetection.SupportedModels.MediaPipeHands;
            handDetector = await handPoseDetection.createDetector(handModel, {
                runtime: 'mediapipe',
                modelType: 'full', 
                solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands'
            });
            outputTextElement.textContent = typedText || `Modalità Attiva: ${currentMode}. Alza Pollice-Indice-Medio (destra) per Menu Radiale.`;
        }

        function calculateDistance(p1, p2) {
            return Math.sqrt(
                Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)
            );
        }
        
        function getPinchData(hand) {
            const thumbTip = hand.keypoints[4]; 
            const PINCH_THRESHOLD = 30; 
            
            const fingerTips = [
                { name: 'Indice', tip: hand.keypoints[8] },
                { name: 'Medio', tip: hand.keypoints[12] },
                { name: 'Anulare', tip: hand.keypoints[16] },
                { name: 'Mignolo', tip: hand.keypoints[20] } 
            ];
            const results = [];
            fingerTips.forEach(finger => {
                const distance = calculateDistance(thumbTip, finger.tip);
                if (distance < PINCH_THRESHOLD){
                    results.push({
                        finger: finger.name,
                        isPinching: true, 
                        tipCoordinates: finger.tip
                    });
                }
            });
            return results;
        }

        function isFingerUp(hand, fingerBaseIndex) {
            const fingerTip = hand.keypoints[fingerBaseIndex + 3];
            const fingerBase = hand.keypoints[fingerBaseIndex];
            
            if (fingerBaseIndex === 1) { // Pollice (base 1)
                return fingerTip.y < hand.keypoints[5].y;
            }
            return fingerTip.y < fingerBase.y; 
        }
        
        function isHexagonGestureActiveCheck(hand) {
            const isIndexUp = isFingerUp(hand, 5); 
            const isMiddleUp = isFingerUp(hand, 9);
            const isThumbUp = isFingerUp(hand, 1); 
            
            const isRingDown = !isFingerUp(hand, 13); 
            const isPinkyDown = !isFingerUp(hand, 17);
            
            return isIndexUp && isMiddleUp && isThumbUp && isRingDown && isPinkyDown;
        }


        function getHandRotationAngle(hand) {
            const wrist = hand.keypoints[0];      
            const palmCenter = hand.keypoints[9]; 
            const deltaX = palmCenter.x - wrist.x;
            const deltaY = palmCenter.y - wrist.y;
            let angleDeg = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
            if (angleDeg < 0) angleDeg += 360; 
            return angleDeg;
        }

        function updateText(char) {
            if (char === 'DEL') {
                typedText = typedText.slice(0, -1);
            } else if (char === 'SPACE') {
                typedText += ' ';
            } else if (char.length === 1) {
                typedText += char;
            }
            outputTextElement.textContent = typedText || `Modalità Attiva: ${currentMode}. Alza Pollice-Indice-Medio (destra) per Menu Radiale.`;
        }
        
        // --- FUNZIONI DI DISEGNO ---
        
        function drawHands(hands) {
            canvasCtx.fillStyle = '#00FF00'; 
            canvasCtx.strokeStyle = '#00FF00'; 
            canvasCtx.lineWidth = 2;
            for (const hand of hands) {
                const keypoints = hand.keypoints;
                const fingerConnections = [
                    [0, 1], [1, 2], [2, 3], [3, 4], 
                    [0, 5], [5, 6], [6, 7], [7, 8], 
                    [0, 9], [9, 10], [10, 11], [11, 12], 
                    [0, 13], [13, 14], [14, 15], [15, 16], 
                    [0, 17], [17, 18], [18, 19], [19, 20] 
                ];
                for (const [start, end] of fingerConnections) {
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(keypoints[start].x, keypoints[start].y);
                    canvasCtx.lineTo(keypoints[end].x, keypoints[end].y);
                    canvasCtx.stroke();
                }
                for (const point of keypoints) {
                    canvasCtx.beginPath();
                    canvasCtx.arc(point.x, point.y, 3, 0, 2 * Math.PI); 
                    canvasCtx.fill();
                }
            }
        }
        
        // Disegno del menu di digitazione (quadrante rotante)
        function drawCharMenu(center, radius, currentAngle) {
            canvasCtx.save();
            canvasCtx.translate(center.x, center.y); 

            // Il menu di digitazione è leggermente spostato per non sovrapporsi all'Esagono
            canvasCtx.translate(0, radius * 1.5); 
            
            // Disegna il background della riga corrente
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            canvasCtx.fillRect(-radius, -radius * 0.4, radius * 2, radius * 0.8);
            canvasCtx.fillStyle = '#FFFFFF';
            canvasCtx.font = '16px sans-serif';
            canvasCtx.textAlign = 'center';
            canvasCtx.textBaseline = 'middle';
            canvasCtx.fillText(`Riga Attiva: ${currentChars.slice(0, 5)}...`, 0, -radius * 0.2);


            // Disegno del quadrante rotante
            const CHAR_COUNT = currentChars.length;
            const angleStep = 360 / CHAR_COUNT;
            let scaledAngle = currentAngle * ROTATION_SENSITIVITY;
            
            for (let i = 0; i < CHAR_COUNT; i++) {
                const char = currentChars[i];
                const charAngle = (i * angleStep - 90) * (Math.PI / 180); 
                
                const charX = radius * Math.cos(charAngle);
                const charY = radius * Math.sin(charAngle);

                let normalizedCurrentAngle = scaledAngle + 90; 
                while (normalizedCurrentAngle > 360) normalizedCurrentAngle -= 360;
                while (normalizedCurrentAngle < 0) normalizedCurrentAngle += 360;

                const startAngle = i * angleStep;
                const endAngle = (i + 1) * angleStep;

                const isSelected = normalizedCurrentAngle >= startAngle && normalizedCurrentAngle < endAngle;

                if (isSelected) {
                    canvasCtx.beginPath();
                    canvasCtx.arc(charX, charY, 18, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = isRightPinchActive ? '#FF6347' : '#00aaff'; 
                    canvasCtx.fill();
                    selectedChar = char; 
                }
                
                canvasCtx.fillStyle = isSelected ? '#000000' : '#FFFFFF';
                canvasCtx.font = 'bold 20px sans-serif';
                canvasCtx.textAlign = 'center';
                canvasCtx.textBaseline = 'middle';
                canvasCtx.fillText(char, charX, charY);
            }
            
            canvasCtx.fillStyle = isRightPinchActive ? '#FF6347' : '#FFFFFF';
            canvasCtx.font = 'bold 28px sans-serif';
            canvasCtx.fillText(`DIGITA: ${selectedChar}`, 0, radius * 0.2); 

            canvasCtx.restore(); 
        }

        // --- FUNZIONE: DISEGNO ESAGONO (STILE FISSO) ---
        function drawHexagonSelector(center, radius, currentAngle) {
            canvasCtx.save();
            canvasCtx.translate(center.x, center.y); 

            const sideCount = HEXAGON_FUNCTIONS.length; 
            const angleStep = 360 / sideCount;

            // Calcola la selezione
            let normalizedCurrentAngle = currentAngle + 90; 
            while (normalizedCurrentAngle > 360) normalizedCurrentAngle -= 360;
            while (normalizedCurrentAngle < 0) normalizedCurrentAngle += 360;
            
            let currentSelectedIndex = Math.floor(normalizedCurrentAngle / angleStep);
            if (currentSelectedIndex >= sideCount) currentSelectedIndex = 0;
            
            // Aggiorna l'indice selezionato per la conferma al rilascio
            currentSelectedHexIndex = currentSelectedIndex;

            canvasCtx.strokeStyle = 'rgba(0, 170, 255, 0.9)';
            canvasCtx.lineWidth = 4;
            canvasCtx.font = 'bold 16px sans-serif';
            canvasCtx.textAlign = 'center';
            canvasCtx.textBaseline = 'middle';

            // Disegna l'Esagono
            canvasCtx.beginPath();
            for (let i = 0; i < sideCount; i++) {
                const angleRad = (i * angleStep - 90) * (Math.PI / 180);
                const x = radius * Math.cos(angleRad);
                const y = radius * Math.sin(angleRad);
                
                if (i === 0) canvasCtx.moveTo(x, y);
                else canvasCtx.lineTo(x, y);
                
                const textAngleRad = ((i + 0.5) * angleStep - 90) * (Math.PI / 180);
                const textX = radius * 0.7 * Math.cos(textAngleRad);
                const textY = radius * 0.7 * Math.sin(textAngleRad);

                const isCurrent = i === currentSelectedIndex;
                
                canvasCtx.fillStyle = isCurrent ? '#FF00FF' : '#FFFFFF';
                
                // Disegna il testo della funzione
                canvasCtx.fillText(HEXAGON_FUNCTIONS[i].name, textX, textY);

                // Evidenzia la punta selezionata
                if (isCurrent) {
                    canvasCtx.beginPath();
                    canvasCtx.arc(x, y, 10, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = '#FF00FF'; 
                    canvasCtx.fill();
                }
            }
            canvasCtx.closePath();
            canvasCtx.stroke();
            
            // Icona di stato centrale
            canvasCtx.beginPath();
            canvasCtx.arc(0, 0, radius * 0.3, 0, 2 * Math.PI); 
            canvasCtx.fillStyle = `rgba(0, 0, 0, 0.8)`; 
            canvasCtx.fill();

            canvasCtx.fillStyle = '#00aaff';
            canvasCtx.font = 'bold 20px sans-serif';
            canvasCtx.fillText(currentMode.replace('_MODE', ''), 0, 0);

            canvasCtx.restore(); 
        }


        // --- Loop di Tracciamento Principale ---
        async function runDetection() {
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            const currentTime = Date.now();
            isRightPinchActive = false;
            
            if (handDetector && videoElement.readyState >= 2) {
                
                canvasCtx.save();
                canvasCtx.translate(canvasElement.width, 0);
                canvasCtx.scale(-1, 1);
                canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

                const hands = await handDetector.estimateHands(videoElement, { flipHorizontal: false });
                drawHands(hands); 
                canvasCtx.restore(); 
                
                let rotationForHexagon = 0; // Rotazione per l'Esagono (Destra)
                let rotationForCharMenu = 0; // Rotazione per il Quadrante (Sinistra)
                
                let isCurrentHexagonGestureActive = false;
                let rightHandFound = false;
                let leftHandFound = false;

                for (const hand of hands) {
                    const handLabel = hand.handedness; 
                    const pinchData = getPinchData(hand);
                    const handRotation = getHandRotationAngle(hand);
                    
                    // 1. Rilevamento Gesto Esagono (Mano Destra) e Input
                    if (handLabel === 'Right') {
                        rightHandFound = true;
                        
                        // GESTO: Alzare 3 dita (Attiva la selezione Esagono)
                        if (isHexagonGestureActiveCheck(hand)) {
                            isCurrentHexagonGestureActive = true;
                            rotationForHexagon = handRotation; 
                        }

                        // INPUT: Pinch Pollice-Indice (Digitazione)
                        const indexPinch = pinchData.find(res => res.finger === 'Indice' && res.isPinching);
                        if (currentMode === TYPING_MODE && !isCurrentHexagonGestureActive && indexPinch) {
                             isRightPinchActive = true; 
                             if (currentTime - lastActionTime > ACTION_DELAY) {
                                 updateText(selectedChar);
                                 lastActionTime = currentTime;
                             }
                        }
                    }

                    // 2. Logica Mano Sinistra: Rotazione e Cambio Riga (Solo in TYPING_MODE)
                    else if (handLabel === 'Left') {
                         leftHandFound = true;
                         if (currentMode === TYPING_MODE) {
                             rotationForCharMenu = handRotation; 
                             
                             // Cambio Riga (Pinch Pollice-X)
                             if (currentTime - lastRowChangeTime > ROW_CHANGE_DELAY) {
                                 const indexPinch = pinchData.find(res => res.finger === 'Indice' && res.isPinching);
                                 const medioPinch = pinchData.find(res => res.finger === 'Medio' && res.isPinching);
                                 const anularePinch = pinchData.find(res => res.finger === 'Anulare' && res.isPinching);
                                 const mignoloPinch = pinchData.find(res => res.finger === 'Mignolo' && res.isPinching);

                                 if (indexPinch) currentChars = CHARS_ROW_1;
                                 else if (medioPinch) currentChars = CHARS_ROW_2;
                                 else if (anularePinch) currentChars = CHARS_ROW_3;
                                 else if (mignoloPinch) currentChars = CHARS_SYMBOLS;
                                 
                                 if (indexPinch || medioPinch || anularePinch || mignoloPinch) {
                                     lastRowChangeTime = currentTime;
                                     selectedChar = currentChars[0];
                                 }
                             }
                         }
                    }
                }
                
                // Se la mano sinistra non è stata trovata, la rotazione del quadrante è gestita dalla destra
                if (currentMode === TYPING_MODE && !leftHandFound) {
                    const rightHand = hands.find(h => h.handedness === 'Right');
                    if (rightHand) {
                        rotationForCharMenu = getHandRotationAngle(rightHand);
                    }
                }

                // --- 3. GESTIONE SELEZIONE AL RILASCIO ---
                
                // Se il gesto era attivo nel frame precedente MA NON lo è più in questo frame
                if (wasHexagonGestureActive && !isCurrentHexagonGestureActive) {
                    // Esegui l'azione selezionata
                    HEXAGON_FUNCTIONS[currentSelectedHexIndex].action();
                    
                    // Se l'azione ha modificato la modalità, aggiorna il testo di output
                    outputTextElement.textContent = typedText || `Modalità Attiva: ${currentMode}. Alza Pollice-Indice-Medio (destra) per Menu Radiale.`;
                }

                // Aggiorna lo stato per il frame successivo
                wasHexagonGestureActive = isHexagonGestureActive;
                isHexagonGestureActive = isCurrentHexagonGestureActive;
                
                // --- 4. RENDERING FINALE ---
                const center = { x: canvasElement.width / 2, y: canvasElement.height / 2 };

                // L'Esagono è sempre disegnato per lo stile, e la selezione è attiva se il gesto è attivo.
                drawHexagonSelector(center, 150, rotationForHexagon);

                if (currentMode === TYPING_MODE) {
                    // Disegna il menu di Digitazione (quadrante)
                    drawCharMenu(center, 100, rotationForCharMenu);
                } 

            }

            requestAnimationFrame(runDetection);
        }

        // --- Avvio Applicazione ---
        async function main() {
            try {
                await tf.ready(); 
                const cameraReady = await setupCamera();
                if (!cameraReady) return;
                await loadDetectors();
                runDetection(); 
            } catch (error) {
                console.error("Errore fatale nell'applicazione:", error);
                outputTextElement.textContent = `ERRORE: ${error.message}. Controlla la console.`;
            }
        }

        main();
    </script>
</body>
</html>